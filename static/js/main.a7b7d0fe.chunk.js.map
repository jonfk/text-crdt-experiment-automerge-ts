{"version":3,"sources":["utils/automerge.ts","components/StateView.tsx","components/Editor.tsx","redux/actions.ts","types/actions.ts","redux/reducers/editor.ts","redux/reducers/index.ts","redux/store.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["changeTextDoc","doc","updatedText","dmp","DiffMatchPatch","diff_match_patch","diff","diff_main","text","toString","diff_cleanupSemantic","patches","patch_make","Automerge","change","doc1","forEach","patch","idx","start1","diffs","operation","changeText","insertAt","bind","split","length","i","deleteAt","getChanges","textBlock","lastSyncedDoc","applyChanges","changes","newDoc","draft","hasUnsyncedChanges","currentDoc","actorId","saveTimingMs","syncTimingMs","prettyBytes","Blob","size","save","JSON","stringify","getConflicts","mapDispatch","updateDraftText","editorId","type","payload","saveTextBlock","syncText","from","to","connectorEditor1","connect","state","editor","editors","connectorEditor2","Editor","otherEditorId","hasUnSyncedChanges","rows","cols","onChange","e","target","value","onClick","disabled","StateView","Editor1","Editor2","initDoc","init","Text","initDoc2","load","initialState","0","1","rootReducer","combineReducers","action","startSave","performance","now","editorState","newTextDoc","endSave","newEditorState","startSync","editorFrom","editorTo","editorToWithChanges","endSync","syncTiming","newEditorTo","newEditorFrom","createStore","App","className","store","pjson","name","dependencies","automerge","style","display","margin","Boolean","window","location","hostname","match","ReactDOM","render","Helmet","charSet","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a7b7d0fe.chunk.js","sourcesContent":["// Adapted from https://lorefnon.tech/2018/09/23/using-google-diff-match-patch-with-automerge-text/\n\nimport DiffMatchPatch from 'diff-match-patch';\nimport Automerge from 'automerge';\n\nimport { TextDoc, Editor } from '../types/models';\n\nexport const changeTextDoc = (\n  doc: Automerge.Doc<TextDoc>,\n  updatedText: string\n): Automerge.Doc<TextDoc> => {\n  const dmp = new DiffMatchPatch.diff_match_patch();\n\n  // Compute the diff:\n  const diff = dmp.diff_main(doc.text.toString(), updatedText);\n  // diff is simply an array of binary tuples representing the change\n  // [[-1,\"The ang\"],[1,\"Lucif\"],[0,\"e\"],[-1,\"l\"],[1,\"r\"],[0,\" shall \"],[-1,\"fall\"],[1,\"rise\"]]\n\n  // This cleans up the diff so that the diff is more human friendly.\n  dmp.diff_cleanupSemantic(diff);\n  // [[-1,\"The angel\"],[1,\"Lucifer\"],[0,\" shall \"],[-1,\"fall\"],[1,\"rise\"]]\n\n  const patches = dmp.patch_make(doc.text.toString(), diff);\n  //console.log(patches);\n\n  // A patch object wraps the diffs along with some change metadata:\n  //\n  // [{\n  //   \"diffs\":[[-1,\"The angel\"],[1,\"Lucifer\"],[0,\" shall \"],[-1,\"fall\"], [1,\"rise\"]],\n  //   \"start1\":0,\n  //   \"start2\":0,\n  //   \"length1\":20,\n  //   \"length2\":18\n  // }]\n\n  // We can use the patch to derive the changedText from the sourceText\n  //console.log(dmp.patch_apply(patches, doc.text.toString())[0]); // \"Lucifer shall rise\"\n\n  // Now we translate these patches to operations against Automerge.Text instance:\n  let newDoc = Automerge.change(doc, doc1 => {\n    patches.forEach(patch => {\n      let idx = patch.start1;\n      if (idx !== null) {\n        patch.diffs.forEach(([operation, changeText]) => {\n          switch (operation) {\n            case 1: // Insertion\n              doc1.text.insertAt?.bind(doc1.text)!(\n                idx!,\n                ...changeText.split('')\n              );\n              idx! += changeText.length;\n              break;\n            case 0: // No Change\n              idx! += changeText.length;\n              break;\n            case -1: // Deletion\n              for (let i = 0; i < changeText.length; i++) {\n                doc1.text.deleteAt!(idx!);\n              }\n              break;\n          }\n        });\n      }\n    });\n  });\n  return newDoc;\n};\n\nexport function initDocWithText(\n  actorId: string,\n  text: string\n): Automerge.Doc<TextDoc> {\n  return Automerge.change(Automerge.init<TextDoc>(actorId), doc => {\n    doc.text = new Automerge.Text(text);\n    return doc.text.insertAt?.bind(doc.text)!(0, ...text.split(''));\n  });\n}\n\nexport function copyDoc<T>(doc: Automerge.Doc<T>): Automerge.Doc<T> {\n  return Automerge.load(Automerge.save(doc));\n}\n\nexport function getChanges(textBlock: Editor): Automerge.Change[] {\n  return Automerge.getChanges(textBlock.lastSyncedDoc, textBlock.doc);\n}\n\nexport function applyChanges(\n  textBlock: Editor,\n  changes: Automerge.Change[]\n): Editor {\n  const newDoc = Automerge.applyChanges(textBlock.doc, changes);\n  return {\n    ...textBlock,\n    doc: newDoc,\n    draft: newDoc.text.toString()\n  };\n}\n\nexport function hasUnsyncedChanges<T>(\n  lastSyncedDoc: Automerge.Doc<T>,\n  currentDoc: Automerge.Doc<T>\n): boolean {\n  return Automerge.getChanges(lastSyncedDoc, currentDoc).length > 0;\n}\n\nexport function getConflicts(doc: Automerge.Doc<TextDoc>): any {\n  return Automerge.getConflicts(doc, 'text');\n}\n\nexport function merge(\n  doc1: Automerge.Doc<TextDoc>,\n  doc2: Automerge.Doc<TextDoc>\n): Automerge.Doc<TextDoc> {\n  return Automerge.merge(doc1, doc2);\n}\n","import React from 'react';\nimport Automerge from 'automerge';\nimport prettyBytes from 'pretty-bytes';\n\nimport { Editor } from '../types/models';\nimport { hasUnsyncedChanges, getConflicts } from '../utils/automerge';\n\ntype Prop = Editor;\n\nexport default ({ doc, lastSyncedDoc, saveTimingMs, syncTimingMs }: Prop) => {\n  return (\n    <div>\n      {/* <span>\n        Current Draft: <pre>{draft}</pre>\n      </span>\n      <br/>\n      <span>\n        Saved Text: <pre>{doc.text.toString()}</pre>\n      </span> */}\n      <br />\n      <span>\n        Text Size: {prettyBytes(new Blob([doc.text.toString()]).size)}\n      </span>\n      <br />\n      <span>\n        CRDT Size: {prettyBytes(new Blob([Automerge.save(doc)]).size)}\n      </span>\n      <br />\n      <span>\n        UnSynced Changes?: {hasUnsyncedChanges(lastSyncedDoc, doc).toString()}\n      </span>\n      <br />\n      <span>Time to Save: {saveTimingMs} ms</span>\n      <br />\n      <span>Time to Sync: {syncTimingMs} ms</span>\n      <br />\n      <span>Conflicts: {JSON.stringify(getConflicts(doc))}</span>\n      {/* <pre>{Automerge.save(text)}</pre> */}\n    </div>\n  );\n};\n","import React from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\n\nimport { RootState, EditorId } from '../types/actions';\nimport { updateDraftText, saveTextBlock, syncText } from '../redux/actions';\nimport StateView from './StateView';\nimport { hasUnsyncedChanges } from '../utils/automerge';\n\nconst mapStateEditor1 = (state: RootState) => ({\n  editor: state.editors[0]\n});\n\nconst mapStateEditor2 = (state: RootState) => ({\n  editor: state.editors[1]\n});\n\nconst mapDispatch = {\n  updateDraftText,\n  saveTextBlock,\n  syncText\n};\n\nconst connectorEditor1 = connect(mapStateEditor1, mapDispatch);\nconst connectorEditor2 = connect(mapStateEditor2, mapDispatch);\n\ntype PropsFromRedux = ConnectedProps<typeof connectorEditor1>;\n\ninterface Props extends PropsFromRedux {}\n\nconst Editor = (editorId: EditorId, otherEditorId: EditorId) => ({\n  editor,\n  updateDraftText,\n  saveTextBlock,\n  syncText\n}: Props) => {\n  const hasUnSyncedChanges: boolean = hasUnsyncedChanges(\n    editor.lastSyncedDoc,\n    editor.doc\n  );\n  return (\n    <div>\n      <h2>Editor {editorId}</h2>\n      <textarea\n        rows={10}\n        cols={40}\n        onChange={e => updateDraftText(editorId, e.target.value)}\n        value={editor.draft}\n      ></textarea>\n      <br />\n      <button\n        onClick={() => saveTextBlock(editorId, editor.draft)}\n        disabled={editor.draft === editor.doc.text.toString()}\n      >\n        Save\n      </button>\n      <button\n        onClick={() => syncText(editorId, otherEditorId)}\n        disabled={!hasUnSyncedChanges}\n      >\n        Sync to other editor\n      </button>\n      <StateView {...editor} />\n    </div>\n  );\n};\n\nexport const Editor1 = connectorEditor1(Editor(0, 1));\nexport const Editor2 = connectorEditor2(Editor(1, 0));\n","import {\n  UPDATE_DRAFT_TEXT,\n  SAVE_TEXT,\n  EditorActionTypes,\n  EditorId,\n  SYNC_TEXT\n} from '../types/actions';\n\nexport function saveTextBlock(\n  editorId: EditorId,\n  text: string\n): EditorActionTypes {\n  return {\n    type: SAVE_TEXT,\n    editorId: editorId,\n    payload: {\n      text: text\n    }\n  };\n}\n\nexport function updateDraftText(\n  editorId: EditorId,\n  text: string\n): EditorActionTypes {\n  return {\n    type: UPDATE_DRAFT_TEXT,\n    editorId: editorId,\n    payload: {\n      text: text\n    }\n  };\n}\n\nexport function syncText(from: EditorId, to: EditorId): EditorActionTypes {\n  return {\n    type: SYNC_TEXT,\n    from: from,\n    to: to\n  };\n}\n","import rootReducer from '../redux/reducers';\n\nexport const SAVE_TEXT = 'SAVE_TEXT';\nexport const UPDATE_DRAFT_TEXT = 'UPDATE_DRAFT_TEXT';\nexport const SYNC_TEXT = 'SYNC_TEXT';\n\nexport type EditorId = 0 | 1;\n\ninterface SaveTextAction {\n  type: typeof SAVE_TEXT;\n  editorId: EditorId;\n  payload: {\n    text: string;\n  };\n}\n\ninterface UpdateDraftTextAction {\n  type: typeof UPDATE_DRAFT_TEXT;\n  editorId: EditorId;\n  payload: {\n    text: string;\n  };\n}\n\ninterface SyncTextAction {\n  type: typeof SYNC_TEXT;\n  from: EditorId;\n  to: EditorId;\n}\n\nexport type EditorActionTypes =\n  | SaveTextAction\n  | UpdateDraftTextAction\n  | SyncTextAction;\nexport type RootState = ReturnType<typeof rootReducer>;\n","import { Editor, TextDoc } from '../../types/models';\nimport {\n  EditorActionTypes,\n  SAVE_TEXT,\n  UPDATE_DRAFT_TEXT,\n  EditorId,\n  SYNC_TEXT\n} from '../../types/actions';\nimport {\n  changeTextDoc,\n  initDocWithText,\n  getChanges,\n  applyChanges,\n  copyDoc,\n  hasUnsyncedChanges\n} from '../../utils/automerge';\n\nexport type EditorsState = Record<EditorId, Editor>;\n\nconst initDoc = initDocWithText('editor-0', '');\nconst initDoc2 = copyDoc(initDoc);\nconst initialState: EditorsState = {\n  0: {\n    doc: initDoc,\n    draft: initDoc.text.toString(),\n    lastSyncedDoc: initDoc,\n    saveTimingMs: 0,\n    syncTimingMs: 0\n  },\n  1: {\n    doc: initDoc2,\n    draft: initDoc2.text.toString(),\n    lastSyncedDoc: initDoc2,\n    saveTimingMs: 0,\n    syncTimingMs: 0\n  }\n};\n\nexport const editorsReducer = (\n  state: EditorsState = initialState,\n  action: EditorActionTypes\n) => {\n  switch (action.type) {\n    case SAVE_TEXT:\n      const startSave = performance.now();\n      const editorState = state[action.editorId];\n      const newTextDoc = changeTextDoc(editorState.doc, action.payload.text);\n      const endSave = performance.now();\n      const newEditorState = {\n        ...editorState,\n        doc: newTextDoc,\n        saveTimingMs: endSave - startSave\n      };\n      return {\n        ...state,\n        [action.editorId]: newEditorState\n      };\n    case UPDATE_DRAFT_TEXT:\n      return {\n        ...state,\n        [action.editorId]: {\n          ...state[action.editorId],\n          draft: action.payload.text\n        }\n      };\n    case SYNC_TEXT:\n      //console.log('syncing');\n      const startSync = performance.now();\n      const editorFrom = state[action.from];\n      const editorTo = state[action.to];\n      const changes = getChanges(editorFrom);\n      const editorToWithChanges = applyChanges(editorTo, changes);\n      const endSync = performance.now();\n      const syncTiming = endSync - startSync;\n\n      if (!hasUnsyncedChanges(editorTo.lastSyncedDoc, editorTo.doc)) {\n        editorToWithChanges.lastSyncedDoc = editorToWithChanges.doc;\n      }\n\n      const newEditorTo = {\n        ...editorToWithChanges,\n        syncTimingMs: syncTiming\n      };\n      const newEditorFrom = {\n        ...editorFrom,\n        lastSyncedDoc: editorFrom.doc,\n        syncTimingMs: syncTiming\n      };\n      return {\n        ...state,\n        [action.to]: newEditorTo,\n        [action.from]: newEditorFrom\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from 'redux';\nimport { editorsReducer } from './editor';\n\nconst rootReducer = combineReducers({\n  editors: editorsReducer\n});\n\nexport default rootReducer;\n","import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\nexport default createStore(rootReducer);\n","import React from 'react';\nimport { Provider } from 'react-redux';\n\nimport './App.css';\nimport { Editor1, Editor2 } from './components/Editor';\nimport store from './redux/store';\nimport pjson from '../package.json';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Provider store={store}>\n        <h1>{pjson.name}</h1>\n        <div>Automerge version : {pjson.dependencies.automerge}</div>\n        <div style={{ display: `flex` }}>\n          <div style={{ margin: `1em` }}>\n            <Editor1 />\n          </div>\n          <div style={{ margin: `1em` }}>\n            <Editor2 />\n          </div>\n        </div>\n      </Provider>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'tslib';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Helmet } from 'react-helmet';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst Root = () => (\n  <div>\n    <Helmet>\n      <meta charSet=\"utf-8\" />\n      <title>Text CRDT App</title>\n    </Helmet>\n    <App />\n  </div>\n);\n\nReactDOM.render(<Root />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}