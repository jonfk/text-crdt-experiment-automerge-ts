{"version":3,"sources":["utils/automerge.ts","components/StateView.tsx","components/Editor.tsx","redux/actions.ts","types/actions.ts","redux/reducers/editor.ts","redux/reducers/index.ts","redux/store.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["changeTextDoc","doc","updatedText","dmp","DiffMatchPatch","diff_match_patch","diff","diff_main","text","toString","diff_cleanupSemantic","patches","patch_make","console","log","patch_apply","newDoc","Automerge","change","doc1","forEach","patch","idx","start1","diffs","operation","changeText","insertAt","bind","split","length","i","deleteAt","getChanges","textBlock","lastSyncedDoc","applyChanges","changes","draft","hasUnsyncedChanges","actorId","prettyBytes","Blob","size","save","JSON","stringify","getConflicts","mapDispatch","updateDraftText","editorId","type","payload","saveTextBlock","syncText","from","to","connectorEditor1","connect","state","editor","editors","connectorEditor2","Editor","otherEditorId","hasUnSyncedChanges","rows","cols","onChange","e","target","value","onClick","disabled","StateView","Editor1","Editor2","initDoc","init","Text","initDoc2","load","initialState","0","1","rootReducer","combineReducers","action","editorState","newTextDoc","newEditorState","editorFrom","editorTo","newEditorTo","newEditorFrom","createStore","App","className","store","pjson","dependencies","automerge","style","display","margin","Boolean","window","location","hostname","match","ReactDOM","render","Helmet","charSet","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b22bdf61.chunk.js","sourcesContent":["// Adapted from https://lorefnon.tech/2018/09/23/using-google-diff-match-patch-with-automerge-text/\n\nimport DiffMatchPatch from 'diff-match-patch';\nimport Automerge from 'automerge';\n\nimport { TextDoc, Editor } from '../types/models';\n\nexport const changeTextDoc = (\n  doc: Automerge.Doc<TextDoc>,\n  updatedText: string\n): Automerge.Doc<TextDoc> => {\n  const dmp = new DiffMatchPatch.diff_match_patch();\n\n  // Compute the diff:\n  const diff = dmp.diff_main(doc.text.toString(), updatedText);\n  // diff is simply an array of binary tuples representing the change\n  // [[-1,\"The ang\"],[1,\"Lucif\"],[0,\"e\"],[-1,\"l\"],[1,\"r\"],[0,\" shall \"],[-1,\"fall\"],[1,\"rise\"]]\n\n  // This cleans up the diff so that the diff is more human friendly.\n  dmp.diff_cleanupSemantic(diff);\n  // [[-1,\"The angel\"],[1,\"Lucifer\"],[0,\" shall \"],[-1,\"fall\"],[1,\"rise\"]]\n\n  const patches = dmp.patch_make(doc.text.toString(), diff);\n  console.log(patches);\n\n  // A patch object wraps the diffs along with some change metadata:\n  //\n  // [{\n  //   \"diffs\":[[-1,\"The angel\"],[1,\"Lucifer\"],[0,\" shall \"],[-1,\"fall\"], [1,\"rise\"]],\n  //   \"start1\":0,\n  //   \"start2\":0,\n  //   \"length1\":20,\n  //   \"length2\":18\n  // }]\n\n  // We can use the patch to derive the changedText from the sourceText\n  console.log(dmp.patch_apply(patches, doc.text.toString())[0]); // \"Lucifer shall rise\"\n\n  // Now we translate these patches to operations against Automerge.Text instance:\n  let newDoc = Automerge.change(doc, doc1 => {\n    patches.forEach(patch => {\n      let idx = patch.start1;\n      if (idx !== null) {\n        patch.diffs.forEach(([operation, changeText]) => {\n          switch (operation) {\n            case 1: // Insertion\n              doc1.text.insertAt?.bind(doc1.text)!(idx!, ...changeText.split(''));\n              idx! += changeText.length;\n              break;\n            case 0: // No Change\n              idx! += changeText.length;\n              break;\n            case -1: // Deletion\n              for (let i = 0; i < changeText.length; i++) {\n                doc1.text.deleteAt!(idx!);\n              }\n              break;\n          }\n        });\n      }\n    });\n  });\n  console.log('incoming text');\n  console.log(newDoc.text.toString());\n  return newDoc;\n}\n\nexport function initDocWithText(\n  actorId: string,\n  text: string\n): Automerge.Doc<TextDoc> {\n  return Automerge.change(Automerge.init<TextDoc>(actorId), doc => {\n    doc.text = new Automerge.Text(text);\n    return doc.text.insertAt?.bind(doc.text)!(0, ...text.split(''));\n  });\n}\n\nexport function getChanges(textBlock: Editor): Automerge.Change[] {\n  return Automerge.getChanges(textBlock.lastSyncedDoc, textBlock.doc);\n}\n\nexport function applyChanges(\n  textBlock: Editor,\n  changes: Automerge.Change[]\n): Editor {\n  const newDoc = Automerge.applyChanges(textBlock.doc, changes);\n  return {\n    ...textBlock,\n    doc: newDoc,\n    draft: newDoc.text.toString()\n  };\n}\n\nexport function hasUnsyncedChanges(textBlock: Editor): boolean {\n  return (\n    Automerge.getChanges(textBlock.lastSyncedDoc, textBlock.doc).length > 0\n  );\n}\n\nexport function getConflicts(textBlock: Editor): any {\n  return Automerge.getConflicts(textBlock.doc, 'text');\n}\n\nexport function merge(\n  doc1: Automerge.Doc<TextDoc>,\n  doc2: Automerge.Doc<TextDoc>\n): Automerge.Doc<TextDoc> {\n  return Automerge.merge(doc1, doc2);\n}\n","import React from 'react';\nimport Automerge from 'automerge';\nimport prettyBytes from 'pretty-bytes';\n\nimport { Editor } from '../types/models';\nimport { hasUnsyncedChanges, getConflicts } from '../utils/automerge';\n\ntype Prop = Editor;\n\nexport default ({ draft, doc, lastSyncedDoc }: Prop) => {\n  return (\n    <div>\n      {/* <span>\n        Current Draft: <pre>{draft}</pre>\n      </span>\n      <br/>\n      <span>\n        Saved Text: <pre>{doc.text.toString()}</pre>\n      </span> */}\n      <br />\n      <span>\n        Text Size: {prettyBytes(new Blob([doc.text.toString()]).size)}\n      </span>\n      <br />\n      <span>\n        CRDT Size: {prettyBytes(new Blob([Automerge.save(doc)]).size)}\n      </span>\n      <br />\n      <span>\n        UnSynced Changes?:{' '}\n        {hasUnsyncedChanges({ draft, doc, lastSyncedDoc }).toString()}\n      </span>\n      <br />\n      <span>\n        Conflicts: {JSON.stringify(getConflicts({ draft, doc, lastSyncedDoc }))}\n      </span>\n      {/* <pre>{Automerge.save(text)}</pre> */}\n    </div>\n  );\n};\n","import React from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\n\nimport { RootState, EditorId } from '../types/actions';\nimport { updateDraftText, saveTextBlock, syncText } from '../redux/actions';\nimport StateView from './StateView';\nimport { hasUnsyncedChanges } from '../utils/automerge';\n\nconst mapStateEditor1 = (state: RootState) => ({\n  editor: state.editors[0]\n});\n\nconst mapStateEditor2 = (state: RootState) => ({\n  editor: state.editors[1]\n});\n\nconst mapDispatch = {\n  updateDraftText,\n  saveTextBlock,\n  syncText\n};\n\nconst connectorEditor1 = connect(mapStateEditor1, mapDispatch);\nconst connectorEditor2 = connect(mapStateEditor2, mapDispatch);\n\ntype PropsFromRedux = ConnectedProps<typeof connectorEditor1>;\n\ninterface Props extends PropsFromRedux {}\n\nconst Editor = (editorId: EditorId, otherEditorId: EditorId) => ({\n  editor,\n  updateDraftText,\n  saveTextBlock,\n  syncText\n}: Props) => {\n  const hasUnSyncedChanges: boolean = hasUnsyncedChanges(editor);\n  return (\n    <div>\n      <h2>Editor {editorId}</h2>\n      <textarea\n        rows={10}\n        cols={40}\n        onChange={e => updateDraftText(editorId, e.target.value)}\n        value={editor.draft}\n      ></textarea>\n      <br />\n      <button onClick={() => saveTextBlock(editorId, editor.draft)}>\n        Save\n      </button>\n      <button\n        onClick={() => syncText(editorId, otherEditorId)}\n        disabled={!hasUnSyncedChanges}\n      >\n        Sync to other editor\n      </button>\n      <StateView\n        draft={editor.draft}\n        doc={editor.doc}\n        lastSyncedDoc={editor.lastSyncedDoc}\n      />\n    </div>\n  );\n};\n\nexport const Editor1 = connectorEditor1(Editor(0, 1));\nexport const Editor2 = connectorEditor2(Editor(1, 0));\n","import {\n  UPDATE_DRAFT_TEXT,\n  SAVE_TEXT,\n  EditorActionTypes,\n  EditorId,\n  SYNC_TEXT\n} from '../types/actions';\n\nexport function saveTextBlock(\n  editorId: EditorId,\n  text: string\n): EditorActionTypes {\n  return {\n    type: SAVE_TEXT,\n    editorId: editorId,\n    payload: {\n      text: text\n    }\n  };\n}\n\nexport function updateDraftText(\n  editorId: EditorId,\n  text: string\n): EditorActionTypes {\n  return {\n    type: UPDATE_DRAFT_TEXT,\n    editorId: editorId,\n    payload: {\n      text: text\n    }\n  };\n}\n\nexport function syncText(from: EditorId, to: EditorId): EditorActionTypes {\n  return {\n    type: SYNC_TEXT,\n    from: from,\n    to: to\n  };\n}\n","import rootReducer from '../redux/reducers';\n\nexport const SAVE_TEXT = 'SAVE_TEXT';\nexport const UPDATE_DRAFT_TEXT = 'UPDATE_DRAFT_TEXT';\nexport const SYNC_TEXT = 'SYNC_TEXT';\n\nexport type EditorId = 0 | 1;\n\ninterface SaveTextAction {\n  type: typeof SAVE_TEXT;\n  editorId: EditorId;\n  payload: {\n    text: string;\n  };\n}\n\ninterface UpdateDraftTextAction {\n  type: typeof UPDATE_DRAFT_TEXT;\n  editorId: EditorId;\n  payload: {\n    text: string;\n  };\n}\n\ninterface SyncTextAction {\n  type: typeof SYNC_TEXT;\n  from: EditorId;\n  to: EditorId;\n}\n\nexport type EditorActionTypes =\n  | SaveTextAction\n  | UpdateDraftTextAction\n  | SyncTextAction;\nexport type RootState = ReturnType<typeof rootReducer>;\n","import { Editor, TextDoc } from '../../types/models';\nimport {\n  EditorActionTypes,\n  SAVE_TEXT,\n  UPDATE_DRAFT_TEXT,\n  EditorId,\n  SYNC_TEXT\n} from '../../types/actions';\nimport {\n  changeTextDoc,\n  initDocWithText,\n  getChanges,\n  applyChanges,\n  merge\n} from '../../utils/automerge';\n\nimport Automerge from 'automerge';\n\nexport type EditorsState = Record<EditorId, Editor>;\n\nconst initDoc = initDocWithText('editor-0', '');\nconst initDoc2: Automerge.Doc<TextDoc> = Automerge.load(\n  Automerge.save(initDoc)\n);\nconst initialState: EditorsState = {\n  0: {\n    doc: initDoc,\n    draft: initDoc.text.toString(),\n    lastSyncedDoc: initDoc\n  },\n  1: {\n    doc: initDoc2,\n    draft: initDoc2.text.toString(),\n    lastSyncedDoc: initDoc2\n  }\n};\n\nexport const editorsReducer = (\n  state: EditorsState = initialState,\n  action: EditorActionTypes\n) => {\n  switch (action.type) {\n    case SAVE_TEXT:\n      const editorState = state[action.editorId];\n      const newTextDoc = changeTextDoc(editorState.doc, action.payload.text);\n      const newEditorState = {\n        ...editorState,\n        doc: newTextDoc\n      };\n      return {\n        ...state,\n        [action.editorId]: newEditorState\n      };\n    case UPDATE_DRAFT_TEXT:\n      return {\n        ...state,\n        [action.editorId]: {\n          ...state[action.editorId],\n          draft: action.payload.text\n        }\n      };\n    case SYNC_TEXT:\n      const editorFrom = state[action.from];\n      const editorTo = state[action.to];\n      console.log('syncing');\n      const changes = getChanges(editorFrom);\n      console.log(changes);\n      const newEditorTo = applyChanges(editorTo, changes);\n      const newEditorFrom = {\n        ...editorFrom,\n        lastSyncedDoc: editorFrom.doc\n      };\n      return {\n        ...state,\n        [action.to]: newEditorTo,\n        [action.from]: newEditorFrom\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from 'redux';\nimport { editorsReducer } from './editor';\n\nconst rootReducer = combineReducers({\n  editors: editorsReducer\n});\n\nexport default rootReducer;\n","import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\nexport default createStore(rootReducer);\n","import React from 'react';\nimport { Provider } from 'react-redux';\n\nimport './App.css';\nimport { Editor1, Editor2 } from './components/Editor';\nimport store from './redux/store';\nimport pjson from '../package.json';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Provider store={store}>\n        <div>Automerge version : {pjson.dependencies.automerge}</div>\n        <div style={{ display: `flex` }}>\n          <div style={{ margin: `1em` }}>\n            <Editor1 />\n          </div>\n          <div style={{ margin: `1em` }}>\n            <Editor2 />\n          </div>\n        </div>\n      </Provider>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'tslib';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Helmet } from 'react-helmet';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst Root = () => (\n  <div>\n    <Helmet>\n      <meta charSet=\"utf-8\" />\n      <title>Text CRDT App</title>\n    </Helmet>\n    <App />\n  </div>\n);\n\nReactDOM.render(<Root />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}